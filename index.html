<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Living Things&#x2122;</title>
<style>
  html, body {
    margin: 0; padding: 0; height: 100%;
    overflow: hidden;
    font-family: sans-serif;
    box-sizing: border-box;
  }
  #scroller {
    position: relative;
    height: 100vh;
    overflow-y: scroll;
    background: #f9f9f9;
  }
  #topSpacer, #bottomSpacer {
    width: 1px;
    position: absolute;
    left: 0;
    top: 0;
  }
  #bottomSpacer {
    top: 0; /* will be updated dynamically */
  }
  .comic-object {
    position: absolute;
    left: 0; right: 0;
    width: 100%;
    border: 9px solid #ddd;
    margin-bottom: 20px;
    background: white;
    box-sizing: border-box;
    min-height: 80vh;
  }
</style>
</head>
<body>

<div id="scroller">
  <div id="topSpacer"></div>
  <div id="bottomSpacer"></div>
</div>

<script>
(async function(){
  // CONFIG
  const BUFFER_BEFORE = 4;  // comics before current index to keep loaded
  const BUFFER_AFTER = 5;  // comics after current index to keep loaded

  const scroller = document.getElementById('scroller');
  const topSpacer = document.getElementById('topSpacer');
  const bottomSpacer = document.getElementById('bottomSpacer');

  let manifest = [];
  let totalComics = 0;

  // Map: comicIndex -> height in px (updated dynamically on load)
  const comicHeights = new Map();

  // Pool of currently loaded comic <object> elements, keyed by comicIndex
  const loadedComics = new Map();

  // Current top comic index in viewport (approximate)
  let currentIndex = 0;

  // Helper to fetch and parse manifest file
  async function loadManifest(url) {
    const resp = await fetch(url);
    if (!resp.ok) throw new Error('Failed to load manifest');
    const text = await resp.text();
    return text.split('\n').map(s => s.trim()).filter(Boolean);
  }

  // Create a comic <object> for a given index
  function createComicObject(index) {
    const obj = document.createElement('object');
    obj.className = 'comic-object';
    obj.type = 'image/svg+xml';
    obj.data = `comics/${manifest[index]}`;
    obj.dataset.index = index;

    obj.style.minHeight = '80vh';

    // When SVG loads, measure height and update layout
    obj.addEventListener('load', () => {
      // Safety: index may have changed if recycled
      const idx = parseInt(obj.dataset.index, 10);
      if (isNaN(idx)) return;
      // Measure height of the SVG document inside object
      try {
        const svgDoc = obj.contentDocument;
        if (svgDoc) {
          const svgEl = svgDoc.documentElement;
          if (svgEl) {
            const bbox = svgEl.getBoundingClientRect();
            // If height is reasonable, store it
            if (bbox.height > 0) {
              comicHeights.set(idx, bbox.height);
              layout(); // re-layout after height update
            }
          }
        }
      } catch(e) {
        // Cross-origin issues? fallback:
        comicHeights.set(idx, obj.offsetHeight || window.innerHeight * 0.8);
        layout();
      }
    });

    return obj;
  }

  // Calculate total height of comics 0..index-1
  function heightUpTo(index) {
    let h = 0;
    for(let i=0; i<index; i++) {
      h += comicHeights.get(i) || window.innerHeight * 0.8;
    }
    return h;
  }

  // Layout the scroll container, position loaded comics, update spacers
  function layout() {
    const totalHeight = heightUpTo(totalComics);
    const beforeHeight = heightUpTo(Math.max(0, currentIndex - BUFFER_BEFORE));
    const afterHeight = totalHeight - heightUpTo(Math.min(totalComics, currentIndex + BUFFER_AFTER + 1));

    topSpacer.style.height = beforeHeight + 'px';
    bottomSpacer.style.height = afterHeight + 'px';
    bottomSpacer.style.top = (beforeHeight + afterHeight + [...loadedComics.values()].reduce((a,b) => a + b.offsetHeight, 0)) + 'px';

    // Position loaded comics
    loadedComics.forEach((obj, idx) => {
      const top = heightUpTo(idx);
      obj.style.top = top + 'px';
    });
  }

  // Determine which comics to load/unload based on scroll position
  function recycle() {
    const scrollTop = scroller.scrollTop;

    // Estimate currentIndex based on scrollTop
    let acc = 0;
    let idx = 0;
    for (; idx < totalComics; idx++) {
      const h = comicHeights.get(idx) || window.innerHeight * 0.8;
      if (acc + h > scrollTop) break;
      acc += h;
    }
    currentIndex = idx;

    // Load buffer range
    const start = Math.max(0, currentIndex - BUFFER_BEFORE);
    const end = Math.min(totalComics - 1, currentIndex + BUFFER_AFTER);

    // Add missing comics
    for(let i=start; i<=end; i++) {
      if (!loadedComics.has(i)) {
        const obj = createComicObject(i);
        loadedComics.set(i, obj);
        scroller.appendChild(obj);
      }
    }

    // Remove comics outside buffer
    loadedComics.forEach((obj, i) => {
      if(i < start || i > end) {
        scroller.removeChild(obj);
        loadedComics.delete(i);
        comicHeights.delete(i); // optionally free height cache to reduce memory
      }
    });

    layout();
  }

  // Initialize: load manifest, setup listeners, and initial load
  async function init() {
    manifest = await loadManifest('comics/manifest.js');
    totalComics = manifest.length;

    // Initial recycle + layout
    recycle();

    // Listen scroll events, debounce layout
    let ticking = false;
    scroller.addEventListener('scroll', () => {
      if (!ticking) {
        ticking = true;
        requestAnimationFrame(() => {
          recycle();
          ticking = false;
        });
      }
    });
  }

  init().catch(console.error);

})();
</script>

</body>
</html>
